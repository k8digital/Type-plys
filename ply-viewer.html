diff --git a/ply-viewer.html b/ply-viewer.html
index 98cae158b70bbf9e5c1a37b241fcabf9e48387c4..1b6bc58b8f718d85f8388add4324bdf92c759e93 100644
--- a/ply-viewer.html
+++ b/ply-viewer.html
@@ -1,108 +1,192 @@
 <!DOCTYPE html>
 <html>
   <head>
     <meta charset="utf-8" />
     <title>PLY Particle Viewer</title>
     <style>
       html, body {
         margin: 0;
         padding: 0;
         overflow: hidden;
         background: #000;
         width: 100%;
         height: 100%;
       }
       canvas {
         display: block;
         width: 100%;
         height: 100%;
       }
     </style>
   </head>
   <body>
+    <div id="overlay" style="position: fixed; top: 10px; left: 10px; color: #fff; font-family: sans-serif; font-size: 14px; z-index: 1; display: flex; gap: 12px; align-items: center;">
+      <span id="status">Loading PLY...</span>
+      <label style="cursor: pointer; padding: 6px 10px; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 4px;">
+        Load local PLY
+        <input id="fileInput" type="file" accept=".ply" style="display: none" />
+      </label>
+    </div>
     <canvas id="c"></canvas>
 
     <!-- Three.js + helpers via CDN -->
     <script src="https://unpkg.com/three@0.167.0/build/three.min.js"></script>
     <script src="https://unpkg.com/three@0.167.0/examples/js/controls/OrbitControls.js"></script>
     <script src="https://unpkg.com/three@0.167.0/examples/js/loaders/PLYLoader.js"></script>
 
     <script>
       // STEP 1: use Lucy (known good) to prove the viewer works.
-      const PLY_URL = "https://threejs.org/examples/models/ply/Lucy100k.ply";
-      const POINT_SIZE = 0.01;
+      const DEFAULT_PLY_URL = "https://threejs.org/examples/models/ply/Lucy100k.ply";
+      const POINT_SIZE = 0.015;
 
       const canvas = document.getElementById("c");
       const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
       renderer.setPixelRatio(window.devicePixelRatio || 1);
 
       const scene = new THREE.Scene();
       scene.background = new THREE.Color(0x000000);
 
       const camera = new THREE.PerspectiveCamera(45, 1, 0.01, 1000);
       camera.position.set(0, 0, 3);
 
+      const overlay = document.getElementById("overlay");
+      const statusEl = document.getElementById("status");
+      const fileInput = document.getElementById("fileInput");
+
       const controls = new THREE.OrbitControls(camera, renderer.domElement);
       controls.enableDamping = true;
       controls.dampingFactor = 0.08;
       controls.enablePan = false;
 
       function onResize() {
         const width = window.innerWidth;
         const height = window.innerHeight;
         renderer.setSize(width, height, false);
         camera.aspect = width / height;
         camera.updateProjectionMatrix();
       }
       window.addEventListener("resize", onResize);
       onResize();
 
       let points = null;
 
+      function disposePoints() {
+        if (!points) return;
+        scene.remove(points);
+        points.geometry.dispose();
+        points.material.dispose();
+        points = null;
+      }
+
+      function updateStatus(text) {
+        statusEl.textContent = text;
+      }
+
       function addPointsFromGeometry(geometry) {
         // Normalize size so giant models still fit the view
         geometry.computeBoundingSphere();
         const bs = geometry.boundingSphere;
         const radius = bs && bs.radius ? bs.radius : 1;
         const scale = 1 / radius;
         geometry.scale(scale, scale, scale);
         geometry.center();
 
+        // Place the camera far enough back to always see the cloud
+        const distance = 2.5;
+        camera.position.set(0, 0, distance);
+        controls.target.set(0, 0, 0);
+        controls.update();
+
         const material = new THREE.PointsMaterial({
           color: 0xffffff,
+          vertexColors: true,
           size: POINT_SIZE,
           sizeAttenuation: true
         });
 
+        disposePoints();
         points = new THREE.Points(geometry, material);
         scene.add(points);
+
+        const vertexCount = geometry.getAttribute("position")?.count || 0;
+        updateStatus(`Vertices: ${vertexCount.toLocaleString()}`);
       }
 
       // Fallback sphere so we never see pure black if loading fails.
       function addFallbackSphere() {
         const sphereGeometry = new THREE.SphereGeometry(1, 128, 128);
         addPointsFromGeometry(sphereGeometry);
+        updateStatus("PLY failed to load; showing fallback sphere");
       }
 
       const loader = new THREE.PLYLoader();
-      loader.load(
-        PLY_URL,
-        function (geometry) {
-          addPointsFromGeometry(geometry);
-        },
-        undefined,
-        function (error) {
-          console.error("Error loading PLY:", error);
+
+      function prepareGeometry(geometry) {
+        const hasPositions = geometry.getAttribute("position")?.count > 0;
+        if (!hasPositions) {
+          console.error("PLY contains no position attribute; using fallback sphere.");
           addFallbackSphere();
+          return;
+        }
+
+        // Some PLY files contain per-vertex colors. Respect them if present.
+        const hasColors = geometry.getAttribute("color");
+        if (!hasColors) {
+          // Ensure the geometry can be drawn even without colors.
+          const count = geometry.getAttribute("position").count;
+          const colors = new Float32Array(count * 3);
+          colors.fill(1.0);
+          geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));
+        }
+
+        addPointsFromGeometry(geometry);
+      }
+
+      function loadFromUrl(url) {
+        updateStatus("Loading PLY...");
+        loader.load(
+          url,
+          function (geometry) {
+            prepareGeometry(geometry);
+          },
+          undefined,
+          function (error) {
+            console.error("Error loading PLY:", error);
+            addFallbackSphere();
+          }
+        );
+      }
+
+      function loadFromFile(file) {
+        updateStatus(`Loading ${file.name}...`);
+        const reader = new FileReader();
+        reader.onload = function (event) {
+          try {
+            const geometry = loader.parse(event.target.result);
+            prepareGeometry(geometry);
+          } catch (err) {
+            console.error("Error parsing PLY file:", err);
+            addFallbackSphere();
+          }
+        };
+        reader.readAsArrayBuffer(file);
+      }
+
+      fileInput.addEventListener("change", (event) => {
+        const file = event.target.files?.[0];
+        if (file) {
+          loadFromFile(file);
         }
-      );
+      });
+
+      loadFromUrl(DEFAULT_PLY_URL);
 
       function animate() {
         requestAnimationFrame(animate);
         controls.update();
         renderer.render(scene, camera);
       }
       animate();
     </script>
   </body>
 </html>
